package z3.scala

import org.scalatest.{FunSuite, Matchers}

class SatSolver extends FunSuite with Matchers {
  import dsl._

  test("Sat solver") {
    case class Literal(name: String, polarity: Boolean)
    type Clause = Set[Literal]

    def DPLL(f : Set[Clause]) : (Boolean, Map[String,Option[Boolean]]) = 
      if(f.isEmpty) (true, Map.empty)
      else if(f.exists(clause => clause.isEmpty)) (false, Map.empty)
      else {
        val z3 = new Z3Context("MODEL" -> true)
        val b = z3.mkBoolSort()

        val literals = f.reduceLeft((a,b) => a ++ b)
        val litMap: _root_.scala.collection.mutable.Map[String,Z3AST] =
          _root_.scala.collection.mutable.Map.empty[String,Z3AST]
        
        literals.foreach(lit => {
          if(!litMap.keySet.contains(lit.name)) {
            val ast = z3.mkBoolConst(z3.mkStringSymbol(lit.name))
            litMap(lit.name) = ast
          }
        })

        val solver = z3.mkSolver

        f.foreach(clause => {
          if (clause.size > 1) {
            val nc: Array[Z3AST] = new Array[Z3AST](clause.size) 
            var c: Int = 0
            clause.foreach(lit => {
              nc(c) = if(lit.polarity) litMap(lit.name) else z3.mkNot(litMap(lit.name))
              c = c + 1
            })
            solver.assertCnstr(nc.reduceLeft(z3.mkOr(_, _)))
          } else {
            val singleLit = clause.head
            if(singleLit.polarity)
              solver.assertCnstr(litMap(singleLit.name))
            else
              solver.assertCnstr(z3.mkNot(litMap(singleLit.name))) 
          }
        })

        val (result, model) = solver.checkAndGetModel()
          
        result match {
          case None => println("There was an error with Z3."); (false, Map.empty)
          case Some(false) => (false, Map.empty) // formula was unsat
          case Some(true) => (true, Map.empty[String,Option[Boolean]] ++ litMap.map(p => (p._1, model.evalAs[Boolean](p._2))))
        }
      }

    // DIMACS parser by Hossein Hojjat
    var form = Set.empty[Clause]
    var clause = Set.empty[Literal]
    var tok:String = ""
    io.Source.fromString(Benchmark.str).getLines().foreach {
      line => if( !line.startsWith("c") && !line.startsWith("p")) {
        val scanner = new _root_.java.util.Scanner(line)
          while(scanner.hasNext) {
          tok = scanner.next
          if (tok != "0") 
            {if( tok.startsWith("-")) clause += Literal(tok.drop(1), false) else clause += Literal(tok, true)} 
          else {
            form += clause
            clause = Set.empty[Literal]
          }}}}
    if (clause.size != 0) form += clause
    val (rs,rm) = DPLL(form)

    rs should equal(true)

    // val pos = rm.filter(p => p._2.isDefined && p._2.get).map(p => p._1.toInt).toSet
    // val neg = rm.filter(p => p._2.isDefined && !p._2.get).map(p => p._1.toInt).toSet
    // val dnt = rm.filter(p => p._2.isEmpty).map(p => p._1.toInt).toSet

    // println("pos: " + pos)
    // println("neg: " + neg)
    // println("dnt: " + dnt)

    def eval(form : Set[Clause], model : Map[String,Option[Boolean]], default : Boolean) : Boolean = {
      form.forall(clause =>
        clause.exists(literal => literal match {
          case Literal(lit, true) => model(lit).getOrElse(default)
          case Literal(lit, false) => !model(lit).getOrElse(!default)
        })
      )
    }

    // Too restrictive:
    // pos should equal(Set(15, 9, 6, 1, 17, 14, 20))
    // neg should equal(Set(12, 8, 19, 4, 11, 13, 16, 5, 10, 2, 18, 7, 3))

    // We evaluate the formula with the model, with don't care set to
    // true and false.
    eval(form, rm, true) should equal(true)
    eval(form, rm, false) should equal(true)
  }


  object Benchmark {
    val str = """c This Formular is generated by mcnf
c
c    horn? no
c    forced? no
c    mixed sat? no
c    clause length = 3
c
p cnf 20  91
 4 -18 19 0
 3 18 -5 0
 -5 -8 -15 0
 -20 7 -16 0
 10 -13 -7 0
 -12 -9 17 0
 17 19 5 0
 -16 9 15 0
 11 -5 -14 0
 18 -10 13 0
 -3 11 12 0
 -6 -17 -8 0
 -18 14 1 0
 -19 -15 10 0
 12 18 -19 0
 -8 4 7 0
 -8 -9 4 0
 7 17 -15 0
 12 -7 -14 0
 -10 -11 8 0
 2 -15 -11 0
 9 6 1 0
 -11 20 -17 0
 9 -15 13 0
 12 -7 -17 0
 -18 -2 20 0
 20 12 4 0
 19 11 14 0
 -16 18 -4 0
 -1 -17 -19 0
 -13 15 10 0
 -12 -14 -13 0
 12 -14 -7 0
 -7 16 10 0
 6 10 7 0
 20 14 -16 0
 -19 17 11 0
 -7 1 -20 0
 -5 12 15 0
 -4 -9 -13 0
 12 -11 -7 0
 -5 19 -8 0
 1 16 17 0
 20 -14 -15 0
 13 -4 10 0
 14 7 10 0
 -5 9 20 0
 10 1 -19 0
 -16 -15 -1 0
 16 3 -11 0
 -15 -10 4 0
 4 -15 -3 0
 -10 -16 11 0
 -8 12 -5 0
 14 -6 12 0
 1 6 11 0
 -13 -5 -1 0
-7 -2 12 0
1 -20 19 0
-2 -13 -8 0
15 18 4 0
-11 14 9 0
-6 -15 -2 0
5 -12 -15 0
-6 17 5 0
-13 5 -19 0
20 -1 14 0
9 -17 15 0
-5 19 -18 0
-12 8 -10 0
-18 14 -4 0
15 -9 13 0
9 -5 -1 0
10 -19 -14 0
20 9 4 0
-9 -2 19 0
-5 13 -17 0
2 -10 -18 0
-18 3 11 0
7 -9 17 0
-15 -6 -3 0
-2 3 -13 0
12 3 -2 0
-2 -3 17 0
20 -15 -16 0
-5 -17 -19 0
-20 -18 11 0
-9 1 -5 0
-19 9 17 0
12 -2 17 0
4 -16 -5 0
"""
  }
}

